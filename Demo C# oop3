// parent.cs

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;



namespace Session03OOPDemo
{
    
    internal class Parent
    {
        
        #region Properties
        public int X {get; set;}
        
        public int Y {get; set;}
        
        
        #endregion
        
        
        #region CTOR
        public Parent(int _x, int _y)
        {
            
            X = _x;
            Y = _y;
            
        }
        
        #endregion
        
        
        #region Methods
        
        public virtual int Multiply()
        {
            return X * Y;
        }
        
        
        public void MyFunc()
        {
            Console.WriteLine("parent class");
            
        }
        
        
        public override string ToString()
        {
            return $"X = {X} , Y = {Y}";
        }
        #endregion
    }
}


// Child.cs

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;



namespace Session03OOPDemo
{
    
    internal class Child : Parent
    {
        
        #region Properties
        
        public int X {get; set;}
        public int Y {get; set;}
        public int Z {get; set;}
        
        #endregion
        
        #region CTOR
        
        public Child(int _x, int _y, int _z):base(_x,_y)
        {
            Z=_z;
        }
        
        #endregion
        
        #region Methods
        
        public override string ToString()
        {
            return $"X = {X} , Y = {Y}";
        }
        
        public override Multiply()
        {
            // return X * Y * Z;
            return base.Multiply() * Z;
        }
        
        
        // new => create new version of function
        
        public new void MyFunc()
        {
            Console.WriteLine("Child Class");
        }
        
        
        
        #endregion
        
    }
}



// main.cs

using Helper;

namespace Session03OOPDemo
{
    
    
    internal class Program
    {
        
        static void Main(string[] args)
        {
            
            #region Inheretence
            
            
            /*
            
               Inheretence :-
               
                     - one of Pillars of Object Orianted Programming
                     - Avoid code dublication
                     
                     
                     
                c# Support 3 Category of Inheretence
                
                
                     1- single Inher
                     
                        - Class Inherit From Only One Class
                    
                    2 - Multilevel Inher
                    
                        - Class Inherit From Class And This Class Inherit From Another Class
                        
                             parent
                             child
                             Grand child
                             
                    3- HierInher
                    
                       - Multiple Classes Can Inherit From Only One Base Class
                       
                    * C#  Doesnt Allow Multiple Inheretence X
            
            
            */
            
            // Parent p1 = new Parent(2,3);
            
            // p1.X = 10;
            // p1.Y = 20;
            
            // Console.WriteLine(p1);
            // Console.WriteLine(p1.Multiply());
            
            // p1.MyFunc();
            
            Child c1 = new Child(1,2,3);
            
            c1.X = 100;
            c1.Y = 200;
            c1.Z = 300;
            
            
            Console.WriteLine(c1);
            Console.WriteLine(c1.Multiply());
            c1.MyFunc();
            
            
            #endregion
            
            #region Access Modifires
            
            TypeA typeA = new TypeA();
            
            // typeA.A = 1;   // private
            // typeA.B = 2;   // internal
            
            
            typeA.C = 3;
            typeA.X = 4;
            typeA.Y = 5;
            
            typeA.Z = 6;
            
            
            #endregion
            
            
        }
    }
}


//TypeA.cs

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Helper
{
    
    public class TypeA
    {
        private int A;
        internal int B;
        public int C;
        
        private protected int X;
        protected int Y;
        protected internal int Z;
    }
}


// TypeB.cs

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Helper
{
    internal class TypeB : TypeA
    {
        
        public TypeB()
        {
            // A = 1; // private Attr cant Inherted
            
            B = 2; // inherited - internal
            
            C = 3; // inherited - public
            
            X = 4; // inherited - private protected - private
            
            Y = 5; // inherited - protected - private
            
            Z = 6; // inherited - internal protected - internal
        }
        
        
    }
}

// TypeC.cs

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Helper
{
   internal class TypeC
   {
       public Test
       {
           TypeB typeB = new TypeB();
           
           typeB.B = 1;
           typeB.C = 2;
           
           typeB.X = 3;
           typeB.Y = 4;
           typeB.Z = 5;
       }
   }
}


// TypeA.cs

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;


namespace S04OOPDemo.PolyMorphismOveriding
{
    
    internal class TypeA
    {
        public int A {get; set;}
        
        public TypeA(int _A)
        {
            A = _A;
            
        }
        
        public void Func1()
        {
            Console.WriteLine("Parent Class");
        }
        
        public virtual void Func2()
        {
            Console.WriteLine($"TypeA : A = {A}");
        }
    }
    
}

// TypeB.cs


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;


namespace S04OOPDemo.PolyMorphismOveriding
{
    
    internal class TypeB : TypeA
    {
        
        public int B {get; set;}
        
        
        public TypeB(int _A, int _B):base(_A)
        {
            
            B = _B;
            
        }
        
        public new void Func1()
        {
            Console.WriteLine("child Class");
        }
        
        
        public override void Func2()
        {
         
         
                Console.WriteLine($"TypeB : A = {A} | B = {B}") ;
        }
    }
}
        
// complex.cs


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;


namespace S04OOPDemo.PolyMorphismOveriding
{
    
    internal class Complex
    {
        
        // prop For Real Num | prop for img Num
        
        public int Real {get; set;}
        
        public int Imag {get; set;}
        
        // public override string ToString()
        // {
        //     return $"{Real} + {Imag}i";
        // }
        
        // operator Overloading => public class Member Method = Static
        
        // operator +
        
        public static Complex operator + (Complex left , Complex right)
        {
            return new Complex()
            {
                Real = (left?.Real ?? 0) + (right?.Real ?? 0),
                Imag = (left?.Imag ?? 0) + (right?.Imag ?? 0)
            };
        }
        
        // operator -
        
        public static Complex operator - (Complex left , Complex right)
        {
            return new Complex()
            {
                Real = (left?.Real ?? 0) - (right?.Real ?? 0),
                Imag = (left?.Imag ?? 0) - (right?.Imag ?? 0)
            };
        }
        
        // operator ++
        
        public static Complex operator ++ (Complex c)
        {
            return new Complex()
            {
                Real = (c?.Real ?? 0) + 1,
                Imag = (c?.Imag ?? 0) + 1
            };
        }
        
        
        public static bool operator > (Complex left , Complex right)
        {
            // i will == left real with right real
            
            if (left.Real == right.Real)
                return left.Imag > right.Imag;
                
            else
            
               return left.Real > right.Real;
               
               
        }
        
           public static bool operator < (Complex left , Complex right)
        {
            // i will == left real with right real
            
            if (left.Real == right.Real)
                return left.Imag < right.Imag;
                
            else
            
               return left.Real < right.Real;
               
               
        }
        
        
        
    }
    
}






