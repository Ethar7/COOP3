// parent.cs

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;



namespace Session03OOPDemo
{
    
    internal class Parent
    {
        
        #region Properties
        public int X {get; set;}
        
        public int Y {get; set;}
        
        
        #endregion
        
        
        #region CTOR
        public Parent(int _x, int _y)
        {
            
            X = _x;
            Y = _y;
            
        }
        
        #endregion
        
        
        #region Methods
        
        public virtual int Multiply()
        {
            return X * Y;
        }
        
        
        public void MyFunc()
        {
            Console.WriteLine("parent class");
            
        }
        
        
        public override string ToString()
        {
            return $"X = {X} , Y = {Y}";
        }
        #endregion
    }
}


// Child.cs

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;



namespace Session03OOPDemo
{
    
    internal class Child : Parent
    {
        
        #region Properties
        
        public int X {get; set;}
        public int Y {get; set;}
        public int Z {get; set;}
        
        #endregion
        
        #region CTOR
        
        public Child(int _x, int _y, int _z):base(_x,_y)
        {
            Z=_z;
        }
        
        #endregion
        
        #region Methods
        
        public override string ToString()
        {
            return $"X = {X} , Y = {Y}";
        }
        
        public override Multiply()
        {
            // return X * Y * Z;
            return base.Multiply() * Z;
        }
        
        
        // new => create new version of function
        
        public new void MyFunc()
        {
            Console.WriteLine("Child Class");
        }
        
        
        
        #endregion
        
    }
}



// main.cs

using Helper;

namespace Session03OOPDemo
{
    
    
    internal class Program
    {
        
        static void Main(string[] args)
        {
            
            #region Inheretence
            
            
            /*
            
               Inheretence :-
               
                     - one of Pillars of Object Orianted Programming
                     - Avoid code dublication
                     
                     
                     
                c# Support 3 Category of Inheretence
                
                
                     1- single Inher
                     
                        - Class Inherit From Only One Class
                    
                    2 - Multilevel Inher
                    
                        - Class Inherit From Class And This Class Inherit From Another Class
                        
                             parent
                             child
                             Grand child
                             
                    3- HierInher
                    
                       - Multiple Classes Can Inherit From Only One Base Class
                       
                    * C#  Doesnt Allow Multiple Inheretence X
            
            
            */
            
            // Parent p1 = new Parent(2,3);
            
            // p1.X = 10;
            // p1.Y = 20;
            
            // Console.WriteLine(p1);
            // Console.WriteLine(p1.Multiply());
            
            // p1.MyFunc();
            
            Child c1 = new Child(1,2,3);
            
            c1.X = 100;
            c1.Y = 200;
            c1.Z = 300;
            
            
            Console.WriteLine(c1);
            Console.WriteLine(c1.Multiply());
            c1.MyFunc();
            
            
            #endregion
            
            #region Access Modifires
            
            TypeA typeA = new TypeA();
            
            // typeA.A = 1;   // private
            // typeA.B = 2;   // internal
            
            
            typeA.C = 3;
            typeA.X = 4;
            typeA.Y = 5;
            
            typeA.Z = 6;
            
            
            #endregion
            
            
        }
    }
}


//TypeA.cs

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Helper
{
    
    public class TypeA
    {
        private int A;
        internal int B;
        public int C;
        
        private protected int X;
        protected int Y;
        protected internal int Z;
    }
}


// TypeB.cs

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Helper
{
    internal class TypeB : TypeA
    {
        
        public TypeB()
        {
            // A = 1; // private Attr cant Inherted
            
            B = 2; // inherited - internal
            
            C = 3; // inherited - public
            
            X = 4; // inherited - private protected - private
            
            Y = 5; // inherited - protected - private
            
            Z = 6; // inherited - internal protected - internal
        }
        
        
    }
}

// TypeC.cs

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Helper
{
   internal class TypeC
   {
       public Test
       {
           TypeB typeB = new TypeB();
           
           typeB.B = 1;
           typeB.C = 2;
           
           typeB.X = 3;
           typeB.Y = 4;
           typeB.Z = 5;
       }
   }
}


// TypeA.cs

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;


namespace S04OOPDemo.PolyMorphismOveriding
{
    
    internal class TypeA
    {
        public int A {get; set;}
        
        public TypeA(int _A)
        {
            A = _A;
            
        }
        
        public void Func1()
        {
            Console.WriteLine("Parent Class");
        }
        
        public virtual void Func2()
        {
            Console.WriteLine($"TypeA : A = {A}");
        }
    }
    
}

// TypeB.cs


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;


namespace S04OOPDemo.PolyMorphismOveriding
{
    
    internal class TypeB : TypeA
    {
        
        public int B {get; set;}
        
        
        public TypeB(int _A, int _B):base(_A)
        {
            
            B = _B;
            
        }
        
        public new void Func1()
        {
            Console.WriteLine("child Class");
        }
        
        
        public override void Func2()
        {
         
         
                Console.WriteLine($"TypeB : A = {A} | B = {B}") ;
        }
    }
}
        
// complex.cs


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;


namespace S04OOPDemo.PolyMorphismOveriding
{
    
    internal class Complex
    {
        
        // prop For Real Num | prop for img Num
        
        public int Real {get; set;}
        
        public int Imag {get; set;}
        
        #region operator Overloading
        // operator Overloading => public class Member Method = Static
        
        // operator +
        
        public static Complex operator + (Complex left , Complex right)
        {
            return new Complex()
            {
                Real = (left?.Real ?? 0) + (right?.Real ?? 0),
                Imag = (left?.Imag ?? 0) + (right?.Imag ?? 0)
            };
        }
        
        // operator -
        
        public static Complex operator - (Complex left , Complex right)
        {
            return new Complex()
            {
                Real = (left?.Real ?? 0) - (right?.Real ?? 0),
                Imag = (left?.Imag ?? 0) - (right?.Imag ?? 0)
            };
        }
        
        // operator ++
        
        public static Complex operator ++ (Complex c)
        {
            return new Complex()
            {
                Real = (c?.Real ?? 0) + 1,
                Imag = (c?.Imag ?? 0) + 1
            };
        }
        
        
        public static bool operator > (Complex left , Complex right)
        {
            // i will == left real with right real
            
            if (left.Real == right.Real)
                return left.Imag > right.Imag;
                
            else
            
               return left.Real > right.Real;
               
               
        }
        
           public static bool operator < (Complex left , Complex right)
        {
            // i will == left real with right real
            
            if (left.Real == right.Real)
                return left.Imag < right.Imag;
                
            else
            
               return left.Real < right.Real;
               
               
        }
        
        #endregion
        
        #region Casting Overloading
        
        public static explicit operator int(Complex c)
        {
            return c.Real;
        }
        
        public static implicit operator string(Complex c)
        {
            return c?.ToString() ?? string Empty;
        }
        
        #endregion
        
        
        public override string ToString()
        {
            return $"{Real} + {Imag}i";
        }
        
    }
    
}


// Helper.cs


namespace S04OOPDemo
{
    
    
    internal static class Helper
    {
        
        public int X {get; set;}
        
        public int Y {get; set;}
        
        public Helper(int _X , int _Y)
        {
            
            X = _X;
            
            Y = _Y;
            
            pi = 3.14;
            
        }
        
        public override string ToString()
        {
            return $"X = {X} + Y = {Y}";
        }
        
        // static CTOR
        
        //      -cant take access modifier
        
        //      class can have only one static CTOR
        //      will exec at least one time per call
        
        
        //     -usage
        
        //      1- call static method or static property
        
        //      2- create object from class
        
        //      3- create object from another class inherited from this class
        
        // static Helper()
        // {
        //     pi = 3.14;
        // }
        
        public static double CmToInch(double cm)
        {
            return cm / 2.54;
        }
        
        private const double pi = 3.14;
        
        // static attr
        
        // private static double pi;
        
        // static prop
        
        public static double PI
        {
            get {return pi;}
            // set {pi = value;}
            
        }
        
        public static double CalcCircleArea(double radius)
        {
            return PI * Math.Pow(radius, 2);
        }
        
    }
    
}

// sealedclass.cs



using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace S04OOPDemo
{
        internal sealed class Parent
        {
            
            private int salary;
            
            public  int Salary
            {
                get { return salary;}
                set { salary = value - 1000;}
            }
            
            public  void Print()
            {
                Console.WriteLine("Hello Parent");
            }
        }
        
        
        class Child : Parent
        {
            
            public override int Salary
            {
                get => base.Salary;
                set => base.Salary = value - 1500;
            }
            
            
            public override void Print()
            {
                Console.WriteLine("Hello child");
            }
           
            
            
        }
}


// program.cs

namespace S04OOPDemo
{
    
    
    internal class Program
    {
        
        #region Method Overloading
        
        public static int Sum(int X , int Y)
        {
            return X + Y;
        }
        
        public static int Sum(int X , int Y , int Z)
        {
            return X + Y + Z;
        }
        
        public static int Sum(double X , double Y)
        {
            return X + Y;
        }
        
        #endregion
        
        
        static void Main(string[] args)
        {
            #region Polymorphism
            
            
            /*
               poly => Many
               
               Morphism => Forms
               
               
               oveloading :-
               
                        -support in class , struct
                        
                        -Method Overloading
                        
                                count of parameter | datatype of parameters | arrange of parameters
                                
                        -types of Overloading
                            1- CTOR Overloading
                            2- operator Overloading
                            3- Method Overloading
                            4- casting operator Overloading
                            5- indexer Overloading
                            
               override
               
                       -must exist with inheritence
                       -support in class only
                       - use keyword new
                       -use keyword override
            */
            
            #region Method Overloading
        
            // Console.WriteLine(Sum(1,2));
            // Console.WriteLine(Sum(1,2,3));
            // Console.WriteLine(Sum(1.4,2.6));
            
            
            #endregion
            
            #region overriding
            
            TypeB typeB = new TypeB(1, 2);
            
            typeB.Func1();
            typeB.Func2();
            
            #endregion
            
            
            #region  Operator Overloading
            
            
            /*
                Complex Number : 2 + 3i + 3 + 5i
            
            */
            
            // Complex c1 = new Complex() { Real = 2, Imag = 3};
            // Complex c2 = new Complex() { Real = 4, Imag = 5};
            
            // Complex c3 = default;
            
            // c3 = c1 + c2;
            
            // c3 = c1 - c2;
            
            // c1++;
            
            // Console.WriteLine(c1);
            // Console.WriteLine(c2);
            
            // Console.WriteLine(c3);
            
            
            // if (c1 > c2)
            //     Console.WriteLine("c1 Greater than c2");
                
            // else
            
            //     Console.WriteLine("c1 less than c2");
                
            // #endregion
            
        
            #endregion
            
            
            #region casting Operator Overloading
            
            Complex c1 = new Complex() { Real = 2, Imag = 3};
            Complex c2 = new Complex() { Real = 4, Imag = 5};
            
            // int Y = (int) c1;
            // Console.WriteLine(Y);
            
            
            string str = (string)c1;
            
            Console.WriteLine(str);
            
            #endregion
            
            
            #endregion
            
            
            #region static class
            
            // Helper h1 = new Helper(1,2);
            
            // Helper h2 = new Helper(1,2);
            // Console.WriteLine(Helper.CmToInch(50));
            
            // Console.WriteLine(Helper.CmToInch(254));
            // Console.WriteLine(Helper.CalcCircleArea(10));
            #endregion
            
            #region SealedClass
            
            // sealed class prevent inheritence
            
            Parent p1 = new Parent();
            
            p1.Print();
            
            #endregion
            
            #region partial class
            
            Employee E1 = new Employee()
            {
                Id = 1,
                Name = "Ahmed",
                Age = 20,
                Salary = 5000,
                CompanyName = "route"
            };
            
            #endregion
        }
    }
}


// Employee.cs


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace S04OOPDemo
{
    internal partial class Employee
    {
        public int Id {get; set;}
        public string Name {get; set;}
        public int Age {get; set;}
        
    }
}


// employeeDevelober.cs

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace S04OOPDemo
{
    internal partial class Employee
    {
        
        public int Salary {get; set;}
        
        public string CompanyName {get; set;}
    }
}





